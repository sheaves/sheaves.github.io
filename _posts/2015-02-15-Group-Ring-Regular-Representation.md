---
layout: post
title: The Group Ring and the Regular Representation
tag: 
- Representation Theory
---

In the [previous post]({% post_url 2015-02-02-Representation-Theory-Decomposing-Representations%}){:target="_blank"}, we saw how to decompose a given group representation into irreducibles. But we still don't know much about the irreducible representations of a (finite) group. What do they look like? How many are there? Infinitely many?

In this post, we'll construct the [group ring](http://en.wikipedia.org/wiki/Group_ring){:target="_blank"} of a group. Treating this as a vector space, we get the [regular representation](http://en.wikipedia.org/wiki/Regular_representation){:target="_blank"}, which turns out to contain *all* the irreducible representations of $G$!

<!--more-->

## The group ring $FG$

Given a (finite) group $G$ and a field $F$, we can treat each element of $G$ as a basis element of a vector space over $F$. The resulting vector space generated by $g \in G$ is

$$
FG := \left\{\sum_{g\in G} \alpha_g g: \alpha_g \in F \right\}.
$$


Let's do this is Sage with the group $G = D_4$ and the field $F = \mathbb{Q}$:

*(The Sage cells in this post are linked, so things may not work if you don't execute them in order.)*

<div class="linked">
  <script type="text/x-sage">
G = DihedralGroup(4)
F = QQ

FG = GroupAlgebra(G,F)

v = FG.an_element()
v
  </script>
</div>

We can view $v \in FG$ as vector in $F^n$, where $n$ is the size of $G$ : 

<div class="linked">
  <script type="text/x-sage">
v.to_vector()
  </script>
</div>

Here, we're treating each $g \in G$ as a basis element of $FG$

<div class="linked">
  <script type="text/x-sage">
for g in G:
    g = FG(g)
    print "{} = {}".format(g.to_vector(),g)
  </script>
</div>

Vectors in $FG$ are added component-wise:

$$
\left(\sum_{g \in G} \alpha_g g\right) + \left(\sum_{g\in G} \beta_g g\right) = \sum_{g \in G} (\alpha_g+\beta_g) g.
$$

<div class="linked">
  <script type="text/x-sage">
w = FG.random_element()  
print 'w = {}'.format(w.to_vector())
print 'v + w = {}'.format((v + w).to_vector())
  </script>
</div>

## Multiplication as a linear transformation

In fact $FG$ is also a  *ring* (called the [**group ring**](http://en.wikipedia.org/wiki/Group_ring){:target="_blank"}), because we can multiply vectors using the multiplication rule of the group $G$:

$$
\left(\sum_{h \in G} \alpha_h h\right) \left(\sum_{g\in G} \beta_g g\right) = \sum_{h,g \in G} (\alpha_h \beta_g) hg.
$$

<div class="linked">
  <script type="text/x-sage">
print 'v * w = {}'.format((v * w).to_vector())
  </script>
</div>

That wasn't very illuminating. However, treating multiplication by $v \in FG$ as a function

$$
\begin{align*}
T_v: FG &\to FG \\
w &\mapsto vw,
\end{align*}
$$

one can check that each $T_v$ is a linear transformation! We can thus represent $T_v$ as a matrix whose columns are $T_v(g), g \in G$:

<div class="linked">
  <script type="text/x-sage">
for g in G:
    g = FG(g)
    print "v*{} = {}".format(g.to_vector(),(v*g).to_vector())

T = matrix([(v*FG(g)).to_vector() for g in G]).transpose()
show(T)
  </script>
</div>

## The regular representation

We're especially interested in $T_g, g \in G$. These are invertible, with inverse $T_{g^{-1}}$, and their matrices are all permutation matrices, because multiplying by $g \in G$ simply permutes elements of $G$:

<div class="linked">
  <script type="text/x-sage">
for v in G:
    v = FG(v)
    show(matrix([(v*FG(g)).to_vector() for g in G]).transpose())
  </script>
</div>

Define a function $\rho_{FG}$ which assigns to each $g\in G$ the corresponding $T_g$:

$$
\begin{align*}
\rho_{FG}: G &\to \mathrm{GL}(FG) \\
g &\mapsto T_g
\end{align*}
$$

Then $(FG,\rho_{FG})$ is the [**regular representation**](http://en.wikipedia.org/wiki/Regular_representation){:target="_blank"} of $G$ over $F$. 

The regular representation of any non-trivial group is not irreducible. In fact, it is a direct sum of *all* the irreducible representations of $G$! What's more, if $(V,\rho)$ is an irreducible representation of $G$ and $\dim V = k$, then $V$ occurs $k$ times in the direct-sum decomposition of $FG$!

Let's apply the decomposition algorithm in the [previous post]({% post_url 2015-02-02-Representation-Theory-Decomposing-Representations%}){:target="_blank"} to $(FG,\rho_{FG})$ (this might take a while to run):

<div class="sage">
  <script type="text/x-sage">
# Define group and its regular representation
G = DihedralGroup(4)
FG = GroupAlgebra(G,QQbar)

def rho(h):
    h = FG(h)
    return matrix([(h*FG(g)).to_vector() for g in G]).transpose()    
    
# Decomposition algorithms
import numpy as np

def is_irreducible(rho,G, n= None):
  """
  If rho is irreducible, returns (True, I)  where I is the n-by-n identity matrix, n = dimension of rho.
  Otherwise, returns (False, H) where H is a non-scalar matrix that commutes with rho(G).
  """
  # Compute the dimension of the representation
  if n is None:
      n = rho(G.identity()).dimensions()[0]
  
  # Run through all r,s = 1,2,...,n
  for r in range(n):
      for s in range(n):
          # Define H_rs
          H_rs = matrix.zero(QQbar,n)
          if r == s:
              H_rs[r,s] = 1
          elif r > s:
              H_rs[r,s] = 1
              H_rs[s,r] = 1
          else: # r < s
              H_rs[r,s] = I
              H_rs[s,r] = -I
          
          # Compute H
          H = sum([rho(g).conjugate_transpose()*H_rs*rho(g) for g in G])/G.cardinality()
          
          # Check if H is scalar
          if H[0,0]*matrix.identity(n) != H:
              return False,H
  
  # If all H are scalar
  return True, matrix.identity(n)

def decompose(rho,G,H):
    """
    Uses the eigenspaces of H to decompose G into subrepresentations.
    Returns a change of basis matrix P and the indices of the block-decomposition of rho in this basis.
    """
    
    # Compute J,P such that H = PJP^(-1)
    J,P = H.jordan_form(QQbar,transformation=True)

    # Compute block subdivisions
    edges = []
    for g in G:
        edges += (P.conjugate_transpose()*rho(g)*P).nonzero_positions()
    graph = Graph(edges, multiedges = False, loops = True)
    subrep_indices = sorted(graph.connected_components(), key=lambda x: x[0])    
    
    return P,subrep_indices  

def irr_decompose(rho,G,index = None):
    """
    Decomposes rho into irreducible representations of G.
    Returns a change of basis matrix P and the indices of the block-decomposition of rho in this basis.
    """
    n = rho(G.identity()).dimensions()[0]
    if index is None:
        index = range(n)
        
    # Test for irreducibility
    is_irred, H = is_irreducible(rho,G,n)
    
    if is_irred:
        subrep_indices = list(np.array(index)[range(n)])
        return H, [subrep_indices]
    else:
        P, subrep_indices = decompose(rho,G,H)
        print [list(np.array(index)[subrep_index]) for subrep_index in subrep_indices]

        new_subrep_indices = []
        new_P_list = []
        
        for subrep_index in subrep_indices:
            
            def subrep(g):
                return (P.inverse()*rho(g)*P)[subrep_index,subrep_index]
            new_P, new_indices = irr_decompose(subrep,G, list(np.array(index)[subrep_index]))
            
            new_subrep_indices += new_indices
            new_P_list += [new_P]
        
        return P*block_diagonal_matrix(new_P_list), new_subrep_indices

def show_irreps(rho,G,P,irrep_indices):
    subdivisions = [i for subrep_index in irrep_indices for i in subrep_index][1:]
    for subrep in irrep_indices:
        for i in subrep[1:]:
            subdivisions.remove(i)

    # Display rho in block-diagonal form
    for g in G:
        M = P.inverse()*rho(g)*P
        M == M*1 # Just for aesthetics
        M.subdivide(subdivisions, subdivisions)
        show(M)

# Execute!
P,irrep_indices = irr_decompose(rho,G)
print irrep_indices
show_irreps(rho,G,P,irrep_indices)    
  </script>
</div>

So the regular representation of $D_4$ decomposes into four (distinct) $1$-dim representations and two (isomorphic) $2$-dim ones.

## Building character

We've spent a lot of time working directly with representations of a group. While more concrete, the actual matrix representations themselves tend to be a little clumsy, especially when the groups in question get large. 

In the next few posts, I'll switch gears to [character theory](http://en.wikipedia.org/wiki/Character_theory){:target="_blank"}, which is a simpler but more powerful way of working with group representations.
